5. Convert the bnf rules into yacc form and write code to generate abstract syntax tree. 


calc.l


%{
#include "calc.tab.h"
#include <stdio.h>
%}

%%
[0-9]+      { yylval.s = strdup(yytext); return NUM; }
"("         { return '('; }
")"         { return ')'; }
[+*/-]      { return yytext[0]; }
[ \t\r]+    ;
\n          { return EOL; }
.           { return yytext[0]; }
%%

int yywrap() { return 1; }



calc.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct node {
    char *t;
    struct node *l, *r;
};

struct node *root;   // AST root

struct node* n(char *t, struct node *l, struct node *r) {
    struct node *p = malloc(sizeof(struct node));
    p->t = strdup(t);
    p->l = l;
    p->r = r;
    return p;
}

void print(struct node *t, int d) {
    if (!t) return;
    print(t->r, d + 1);
    for (int i = 0; i < d; i++) printf("   ");
    printf("%s\n", t->t);
    print(t->l, d + 1);
}

int yylex();
int yyerror(char *s) { printf("Error: %s\n", s); return 0; }
%}

%union {
    char *s;
    struct node *n;
}

%token <s> NUM
%token EOL
%type <n> expr term fac

%left '+' '-'
%left '*' '/'

%%

input:
      expr EOL      { root = $1; printf("\nAST:\n"); print(root, 0); }
    | EOL
    ;

expr:
      expr '+' term { $$ = n("+", $1, $3); }
    | expr '-' term { $$ = n("-", $1, $3); }
    | term          { $$ = $1; }
    ;

term:
      term '*' fac  { $$ = n("*", $1, $3); }
    | term '/' fac  { $$ = n("/", $1, $3); }
    | fac           { $$ = $1; }
    ;

fac:
      '(' expr ')'  { $$ = $2; }
    | NUM           { $$ = n($1, NULL, NULL); }
    ;

%%

int main() {
    printf("Enter expression:\n");
    yyparse();
    return 0;
}


execution
		flex calc.l
		bison -d calc.y
		gcc lex.yy.c calc.tab.c
		./a.out

input 
	(2+3)*5

